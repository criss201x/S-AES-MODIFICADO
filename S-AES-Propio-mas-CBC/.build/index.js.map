{
  "version": 3,
  "sources": ["../index.ts"],
  "sourcesContent": ["// Implementaci\u00F3n del algoritmo S-AES con modificaciones\n\n// Nuevas cajas de sustituci\u00F3n S complementarias\nconst S_BOX_1: number[][] = [\n  [9, 4, 10, 11],\n  [13, 1, 8, 5],\n  [6, 2, 0, 3],\n  [12, 14, 15, 7]\n];\n\nconst S_BOX_2: number[][] = [\n  [3, 8, 11, 1],\n  [9, 12, 2, 13],\n  [0, 4, 6, 5],\n  [10, 14, 7, 15]\n];\n\n// Nueva pol\u00EDtica de corrimiento de ShiftRows\nfunction shiftRows(state: number[]): void {\n  const temp = state[1];\n  state[1] = state[3];\n  state[3] = temp;\n}\n\n// Nuevas matrices de MixColumns complementarias\nconst MIX_COLUMNS_MATRIX_1: number[][] = [\n  [0x02, 0x03, 0x01, 0x01],\n  [0x01, 0x02, 0x03, 0x01],\n  [0x01, 0x01, 0x02, 0x03],\n  [0x03, 0x01, 0x01, 0x02]\n];\n\nconst MIX_COLUMNS_MATRIX_2: number[][] = [\n  [0x0E, 0x0B, 0x0D, 0x09],\n  [0x09, 0x0E, 0x0B, 0x0D],\n  [0x0D, 0x09, 0x0E, 0x0B],\n  [0x0B, 0x0D, 0x09, 0x0E]\n];\n\n// Nuevas constantes del KeyExpansion\nconst ROUND_CONSTANTS: number[] = [\n  0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36\n];\n\n// Nueva pol\u00EDtica de relleno de bloques\nfunction padBlock(block: number[]): number[] {\n  const paddedBlock = [...block];\n  while (paddedBlock.length < 4) {\n    paddedBlock.push(0x00);\n  }\n  return paddedBlock;\n}\n\n// Funci\u00F3n de sustituci\u00F3n no lineal utilizando una caja S complementaria\nfunction substituteNibbles(nibble: number, sBox: number[][]): number {\n  const row = (nibble >> 4) & 0x0F;\n  const column = nibble & 0x0F;\n  return sBox[row][column];\n}\n\nfunction permuteNibbles(nibble: number, mixColumnsMatrix: number[][]): number {\n  const result: number[] = [0, 0, 0, 0];\n\n  for (let i = 0; i < 4; i++) {\n    for (let j = 0; j < 4; j++) {\n      result[i] ^= galoisMultiplication(nibble >> (j * 4) & 0x0F, mixColumnsMatrix[i][j]);\n    }\n  }\n\n  let permutedNibble = 0;\n  for (let i = 0; i < 4; i++) {\n    permutedNibble |= result[i] << (i * 4);\n  }\n\n  return permutedNibble;\n}\n\n// Funci\u00F3n de multiplicaci\u00F3n en el campo de Galois\nfunction galoisMultiplication(a: number, b: number): number {\n  let p = 0;\n  let counter = 0;\n  let hiBitSet: boolean;\n  while (counter < 8) {\n    if ((b & 1) === 1) {\n      p ^= a;\n    }\n    hiBitSet = (a & 0x80) !== 0;\n    a <<= 1;\n    if (hiBitSet) {\n      a ^= 0x1B;\n    }\n    b >>= 1;\n    counter++;\n  }\n  return p & 0xFF;\n}\n\n// Funci\u00F3n principal de encriptaci\u00F3n\nfunction encrypt(plaintext: number[], key: number[]): number[] {\n  // Implementar el proceso de encriptaci\u00F3n seg\u00FAn el algoritmo S-AES\n  // Utilizar las funciones y estructura del S-AES original y aplicar las modificaciones propuestas\n\n  let state = [...plaintext];\n  const roundKeys = keyExpansion(key);\n\n  // Resto del proceso de encriptaci\u00F3n...\n\n  return state;\n}\n\n// Funci\u00F3n principal de desencriptaci\u00F3n\nfunction decrypt(ciphertext: number[], key: number[]): number[] {\n  // Implementar el proceso de desencriptaci\u00F3n seg\u00FAn el algoritmo S-AES\n  // Utilizar las funciones y estructura del S-AES original y aplicar las modificaciones propuestas\n\n  let state = [...ciphertext];\n  const roundKeys = keyExpansion(key);\n\n  // Resto del proceso de desencriptaci\u00F3n...\n\n  return state;\n}\n\n// Funci\u00F3n de expansi\u00F3n de clave (Key Expansion) para generar las claves de ronda\nfunction keyExpansion(key: number[]): number[][] {\n  // Implementar el proceso de expansi\u00F3n de clave seg\u00FAn el algoritmo S-AES\n  // Utilizar las constantes y funciones del S-AES original y aplicar las modificaciones propuestas\n\n  let roundKeys: number[][] = [];\n\n  // Resto del proceso de expansi\u00F3n de clave...\n\n  return roundKeys;\n}\n\n// Funci\u00F3n principal de ejecuci\u00F3n del algoritmo\nfunction main() {\n  const plaintext: number[] = [0x32, 0x88]; // Datos de entrada (2 bytes)\n  const key: number[] = [0x2b, 0x7e]; // Clave (2 bytes)\n\n  console.log('Plaintext:', plaintext.map(byte => byte.toString(16).padStart(2, '0')).join(' '));\n  console.log('Key:', key.map(byte => byte.toString(16).padStart(2, '0')).join(' '));\n\n  const ciphertext = encrypt(plaintext, key);\n  console.log('Ciphertext:', ciphertext.map(byte => byte.toString(16).padStart(2, '0')).join(' '));\n\n  const decryptedPlaintext = decrypt(ciphertext, key);\n  console.log('Decrypted plaintext:', decryptedPlaintext.map(byte =>     byte.toString(16).padStart(2, '0')).join(' '));\n}\n\n// Ejecutar el algoritmo\nmain();\n\n/*\n* Usando encriptaci\u00F3n por bloques independientes (CBC), encriptar 10 palabras de el algoritmo propio\n*/\nconsole.log(\"10 de el algoritmo propio\");\n// Funci\u00F3n principal de encriptaci\u00F3n con CBC\nfunction encryptWithCBC(plaintextList: number[][], key: number[]): number[][] {\n  const ciphertextList: number[][] = [];\n  let previousBlock: number[] = [0x00, 0x00]; // Valor inicial para el primer bloque\n\n  for (let i = 0; i < plaintextList.length; i++) {\n    const plaintextBlock = plaintextList[i];\n\n    // Realizar XOR entre el bloque de texto plano y el bloque cifrado anterior\n    const xorResult = plaintextBlock.map((byte, index) => byte ^ previousBlock[index]);\n\n    // Encriptar el bloque XOR resultante\n    const ciphertextBlock = encrypt(xorResult, key);\n\n    // Agregar el bloque cifrado a la lista de bloques cifrados\n    ciphertextList.push(ciphertextBlock);\n\n    // Establecer el bloque cifrado actual como el bloque anterior para el siguiente ciclo\n    previousBlock = ciphertextBlock;\n  }\n\n  return ciphertextList;\n}\n\nconst words = [\n  [0x75, 0x6e],\n  [0x69, 0x76],\n  [0x65, 0x72],\n  [0x73, 0x69],\n  [0x64, 0x61],\n  [0x64, 0x64],\n  [0x69, 0x73],\n  [0x74, 0x72],\n  [0x69, 0x74],\n  [0x61, 0x6c]\n];\n\n// Clave de encriptaci\u00F3n de 2 caracteres (16 bits)\nconst key = [0x2b, 0x7e];\n\n// Encriptar las palabras cifradas utilizando CBC\nconst ciphertextList = encryptWithCBC(words, key);\n\n// Imprimir los bloques cifrados en hexadecimal\nconsole.log(\"Ciphertext:\");\nciphertextList.forEach(block => {\n  const hexBlock = block.map(byte => byte.toString(16).padStart(2, '0')).join(' ');\n  console.log(hexBlock);\n});"],
  "mappings": "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",
  "names": ["key", "ciphertextList"]
}
